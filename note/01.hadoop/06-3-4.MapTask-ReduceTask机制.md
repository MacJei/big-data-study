# MapTask 机制

![1](img/04.mr15.png)

- Read阶段
  - MapTask通过用户编写的RecordReader，从输入InputFormat中解析出一个个key/value。
- Map阶段
  - 将解析出的key/value交给用户编写map()函数处理
  - 产生一系列新的key/value
- Collect收集阶段
  - 在编写map()函数中
  - 当数据处理完成后，一般会调用OutputCollector.collect()输出结果
    - 在该函数内部，将生成的key/value分区（调用Partitioner）写入环形内存缓冲区
- Spill阶段，即“溢写”
  - 当环形缓冲区满后，将数据写到本地磁盘上，生成一个临时文件
    - 将数据写入本地磁盘之前，先对数据进行一次本地排序
    - 在必要时对数据进行合并、压缩等操作
  - 步骤1
    - 利用==快速排序算法对缓存区内的数据进行排序==
      - 先按照分区编号Partition进行排序
      - 然后按照key进行排序
    - 经过排序后，数据以**分区为单位**聚集在一起，且同一分区内所有数据按照key有序
  - 步骤2
    - 按分区编号由小到大依次将每个分区中的数据写入任务工作目录下的临时文件output/spillN.out中
      - N表示当前溢写次数
    - 如果用户设置了Combiner，则写入文件之前，对每个分区中的数据进行一次聚集操作
  - 步骤3
    - 将分区数据的**元信息**写到内存索引数据结构SpillRecord中
    - 每个分区的元信息包括
      - 在临时文件中的偏移量
      - 压缩前数据大小
      - 压缩后数据大小
    - 当前内存索引大小超过1MB则将内存索引写到文件output/spillN.out.index中
- Combine阶段
  - 所有数据处理完成后
  - MapTask对所有临时文件进行一次合并
    - 以分区为单位进行合并
    - 采用多轮递归合并的方式
    - 每轮合并io.sort.factor（默认10）个文件
    - 将产生的文件重新加入待合并列表中，对文件排序后，重复以上过程，直到最终得到一个大文件
  - 确保每个MapTask最终只会生成一个数据文件
    - 避免同时打开大量文件和同时读取大量小文件产生的随机读取带来的开销
  - 保存到文件output/file.out中
  - 生成相应的索引文件output/file.out.index



# ReduceTask 机制



![1](img/04.mr16.png)



- Copy阶段

  - 从各个MapTask上远程拷贝一片数据
  - 针对某一片数据，如果其大小超过一定阈值，则写到磁盘上，否则直接放到内存中。

- Merge阶段

  - 在远程拷贝数据的同时
  - ReduceTask启动了两个后台线程对内存和磁盘上的文件进行合并
    - 防止内存使用过多或磁盘上文件过多

- Sort阶段

  - 按照MapReduce语义，用户编写reduce()函数输入数据是按key进行聚集的一组数据
  - 为了将key相同的数据聚在一起，Hadoop采用了基于排序的策略
  - 由于各个MapTask已经实现对自己的处理结果进行了局部排序
    - ReduceTask只需对所有数据进行一次归并排序即可。

- Reduce阶段

  - reduce()函数将计算结果写到HDFS上

    

## 设置ReduceTask并行度

- ReduceTask 并行度同样影响整个Job的执行并发度和执行效率
- 与MapTask 并发数由切片数决定不同
- ReduceTask 数量可直接手动设置

```java
// 默认值是1，手动设置为4
job.setNumReduceTasks(4);
```



- 实验：测试ReduceTask多少合适
  - 实验环境：1个Master节点，16个Slave节点：CPU:8GHZ，内存: 2G
  - 实验结论
    - 并行度提高，反而会降低效率

| MapTask =16 |      |      |      |      |      |      |      |      |      |      |
| ----------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| ReduceTask  | 1    | 5    | 10   | 15   | 16   | 20   | 25   | 30   | 45   | 60   |
| 总时间      | 892  | 146  | 110  | 92   | 88   | 100  | 128  | 101  | 145  | 104  |

- 注意事项
  - ReduceTask=0
    - 没有Reduce阶段，输出文件个数与Map个数一致
    - 实际生产推荐，如果可以在map阶段解决的话
    - 少了Shuffe阶段和reduce阶段
      - 其中Shuffe阶段需要大量的排序，IO操作，耗时严重
  - ReduceTask 的默认值 1，输出文件就一个
  - 如果数据分布不均衡，在reduce阶段产生数据倾斜
  - ReduceTask的数量不是任意设置的
    - 考虑业务逻辑需求
    - ==计算全局汇总结果，只能是1个ReduceTask==
  - 具体多少ReduceTask需要依照集群性能而定
  - 如果分区不是1，但是ReduceTask = 1，那么不会执行分区过程
    - 在源码中对`ReduceNum == 1`进行了判断
    - 大于1才会执行分区过程