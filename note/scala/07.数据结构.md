# 介绍

- Scala同时支持不可变集合和可变集合，不可变集合可以安全的并发访问
- 两个主要的包
  - 不可变集合
    - scala.collection.immutable
    - 默认采用
    - ==集合本身不能动态变化==
      - 类似java的数组，是不可以动态增长的
- 可变集合
    - scala.collection.mutable
    - 集合本身可以动态变化，可以动态增长
  
- 集合有三大类

  - 序列Seq
  - 集Set
  - 映射Map

- 所有的集合都扩展自Iterable特质

- java示例

```java
import java.util.ArrayList;

public class JavaCollection {
    public static void main(String[] args) {
        //不可变集合类似java的数组
        int[] nums = new int[3];
        nums[2] = 11; //?
        nums[2] = 22;
        //nums[3] = 90; // 报错

        //        String[] names = {"bj", "sh"};
        //        System.out.println(nums + " " + names);
        //
        //        //可变集合举例
        ArrayList al = new ArrayList<String>();
        al.add("zs");
        al.add("zs2");
        System.out.println(al + " 地址= " + al.hashCode()); //地址
        al.add("zs3");
        System.out.println(al + " 地址2=" + al.hashCode()); //地址
    }
}
```



# 不可变集合继承层次

- 公共父类
  - Iterable

<img src="../img/scala/28.jpg" alt="img" style="zoom:150%;" />

- Set、Map是Java中也有的集合
- Seq是Java没有的，发现List归属到Seq了，List就和java不是同一个概念

- 数据结构比如Queue 和 Stack被归属到LinearSeq

- Map体系有一个SortedMap,说明Scala的Map可以支持排序

- IndexSeq 和 LinearSeq 的区别
  - IndexSeq是通过索引来查找和定位，因此速度快
    - 如String就是一个索引集合，通过索引即可定位
  - LinearSeq 是线型的，即有头尾的概念，一般是通过遍历来查找
    - 价值在于应用到一具体的应用场景 
      - 电商网站, 大数据推荐系统 :最近浏览的10个商品



# 可变集合继承层次

<img src="../img/scala/29.jpg" alt="img" style="zoom: 150%;" />

- 在可变集合中比不可变集合更加丰富

- 在Seq集合中， 增加了 Buffer 集合
  - 常用的有ArrayBuffer和ListBuffer

- 如果涉及到线程安全可以选择使用syn.. 开头的集合



# Array

- 定长数组

## 定义

- 方式1

```scala
// 这里的数组等同于Java中的数组,中括号的类型就是数组的类型
val arr1 = new Array[Int](10)
//赋值,集合元素采用小括号访问
arr1(1) = 7 
```

```scala
object ArrayDemo01 {
    def main(args: Array[String]): Unit = {
        //说明
        //1. 创建了一个Array对象,
        //2. [Int] 表示泛型，即该数组中，只能存放Int
        //3. [Any] 表示 该数组可以存放任意类型
        //4. 在没有赋值情况下，各个元素的值 0
        //5.  arr01(3) = 10 表示修改 第4个元素的值
        val arr01 = new Array[Int](4) //底层 int[] arr01 = new int[4]
        println(arr01.length) // 4
        println("arr01(0)=" + arr01(0)) // 0
        //遍历
        for (i <- arr01) {
            println(i)
        }
    }
}
```

- 方式2

```scala
//在定义数组时，直接赋值
//使用apply方法创建数组对象
val arr1 = Array(1, 2)
```

```scala
object ArrayDemo02 {
    def main(args: Array[String]): Unit = {
        //说明
        //1. 使用的是 object Array 的apply
        //2. 直接初始化数组，这时因为你给了 整数和 "", 这个数组的泛型就Any
        //3. 遍历方式一样
        var arr02 = Array(1, 3, "xx")
        arr02(1) = "xx"
        for (i <- arr02) {
            println(i)
        }
        //可使用传统的方式遍历，使用下标的方式遍历
        for (index <- 0 until arr02.length) {
            printf("arr02[%d]=%s", index , arr02(index) + "\t")
        }
    }
}
```



# ArrayBuffer

- 变长数组

  

## 定义

```scala
//定义/声明
val arr2 = ArrayBuffer[Int]()
//追加值/元素
arr2.append(7)
//重新赋值
arr2(0) = 7
```

- 示例

```scala
import scala.collection.mutable.ArrayBuffer

object ArrayBufferDemo01 {
    def main(args: Array[String]): Unit = {
        //创建ArrayBuffer
        val arr01 = ArrayBuffer[Any](3, 2, 5)

        //访问，查询
        //通过下标访问元素
        println("arr01(1)=" + arr01(1)) // arr01(1) = 2
        //遍历
        for (i <- arr01) {
            println(i)
        }
        println(arr01.length) //3
        println("arr01.hash=" + arr01.hashCode())

        //修改 [修改值，动态增加]
        //使用append 追加数据 ,append支持可变参数
        //可以理解成java的数组的扩容
        arr01.append(90.0,13) // (3,2,5,90.0,13)
        println("arr01.hash=" + arr01.hashCode())

        arr01(1) = 89 //修改 (3,89,5,90.0,13)
        println("--------------------------")
        for (i <- arr01) {
            println(i)
        }

        //删除...
        //删除,是根据下标来说
        arr01.remove(0)  // (89,5,90.0,13)
        println("--------删除后的元素遍历---------------")
        for (i <- arr01) {
            println(i)
        }
        println("最新的长度=" + arr01.length) // 4
    }
}
```

- ArrayBuffer是变长数组，类似java的ArrayList

- `val arr2 = ArrayBuffer[Int]()` 使用的apply方法构建对象

- `def append(elems: A*) { appendAll(elems) }` 接收的是可变参数

- 每append一次，arr在底层会重新分配空间，进行扩容，arr2的内存地址会发生变化，也就成为新的ArrayBuffer

  - 即使是val定义，arr也会重新分配空间

    

# Array和ArrayBuffer转换

- 说明
  - 在开发中，我们可能使用对定长数组和变长数组，进行转换
    - arr1.toBuffer //定长数组转可变数组
      - 返回结果是一个可变数组， arr1本身没有变化
    - arr2.toArray //可变数组转定长数组
      - 返回结果是一个定长数组， arr2本身没有变化

```scala
import scala.collection.mutable.ArrayBuffer

object Array22ArrayBuffer {
    def main(args: Array[String]): Unit = {

        val arr2 = ArrayBuffer[Int]()
        // 追加值
        arr2.append(1, 2, 3)
        println(arr2)

        //说明
        //1. arr2.toArray 调用 arr2的方法 toArray
        //2. 将 ArrayBuffer ---> Array
        //3. arr2本身没有任何变化
        val newArr = arr2.toArray
        println(newArr)

        //说明
        //1. newArr.toBuffer 是把 Array->ArrayBuffer
        //2. 底层的实现
        /*
     override def toBuffer[A1 >: A]: mutable.Buffer[A1] = {
    val result = new mutable.ArrayBuffer[A1](size)
    copyToBuffer(result)
    result
  }
     */
        //3. newArr本身没变化
        val newArr2 = newArr.toBuffer
        newArr2.append(123)
        println(newArr2)
    }
}
```



# 多维数组

