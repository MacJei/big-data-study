# 介绍

- Scala同时支持不可变集合和可变集合，不可变集合可以安全的并发访问
- 两个主要的包
  - 不可变集合
    - scala.collection.immutable
    - 默认采用
    - ==集合本身不能动态变化==
      - 类似java的数组，是不可以动态增长的
- 可变集合
    - scala.collection.mutable
    - 集合本身可以动态变化，可以动态增长
  
- 集合有三大类

  - 序列Seq
  - 集Set
  - 映射Map

- 所有的集合都扩展自Iterable特质

- java示例

```java
import java.util.ArrayList;

public class JavaCollection {
    public static void main(String[] args) {
        //不可变集合类似java的数组
        int[] nums = new int[3];
        nums[2] = 11; //?
        nums[2] = 22;
        //nums[3] = 90; // 报错

        //        String[] names = {"bj", "sh"};
        //        System.out.println(nums + " " + names);
        //
        //        //可变集合举例
        ArrayList al = new ArrayList<String>();
        al.add("zs");
        al.add("zs2");
        System.out.println(al + " 地址= " + al.hashCode()); //地址
        al.add("zs3");
        System.out.println(al + " 地址2=" + al.hashCode()); //地址
    }
}
```



# 不可变集合继承层次

- 公共父类
  - Iterable

<img src="../img/scala/28.jpg" alt="img" style="zoom:150%;" />

- Set、Map是Java中也有的集合
- Seq是Java没有的，发现List归属到Seq了，List就和java不是同一个概念

- 数据结构比如Queue 和 Stack被归属到LinearSeq

- Map体系有一个SortedMap,说明Scala的Map可以支持排序

- IndexSeq 和 LinearSeq 的区别
  - IndexSeq是通过索引来查找和定位，因此速度快
    - 如String就是一个索引集合，通过索引即可定位
  - LinearSeq 是线型的，即有头尾的概念，一般是通过遍历来查找
    - 价值在于应用到一具体的应用场景 
      - 电商网站, 大数据推荐系统 :最近浏览的10个商品



# 可变集合继承层次

<img src="../img/scala/29.jpg" alt="img" style="zoom: 150%;" />

- 在可变集合中比不可变集合更加丰富

- 在Seq集合中， 增加了 Buffer 集合
  - 常用的有ArrayBuffer和ListBuffer

- 如果涉及到线程安全可以选择使用syn.. 开头的集合



# Array

- 定长数组

## 定义

- 方式1

```scala
// 这里的数组等同于Java中的数组,中括号的类型就是数组的类型
val arr1 = new Array[Int](10)
//赋值,集合元素采用小括号访问
arr1(1) = 7 
```

```scala
object ArrayDemo01 {
    def main(args: Array[String]): Unit = {
        //说明
        //1. 创建了一个Array对象,
        //2. [Int] 表示泛型，即该数组中，只能存放Int
        //3. [Any] 表示 该数组可以存放任意类型
        //4. 在没有赋值情况下，各个元素的值 0
        //5.  arr01(3) = 10 表示修改 第4个元素的值
        val arr01 = new Array[Int](4) //底层 int[] arr01 = new int[4]
        println(arr01.length) // 4
        println("arr01(0)=" + arr01(0)) // 0
        //遍历
        for (i <- arr01) {
            println(i)
        }
    }
}
```

- 方式2

```scala
//在定义数组时，直接赋值
//使用apply方法创建数组对象
val arr1 = Array(1, 2)
```

```scala
object ArrayDemo02 {
    def main(args: Array[String]): Unit = {
        //说明
        //1. 使用的是 object Array 的apply
        //2. 直接初始化数组，这时因为你给了 整数和 "", 这个数组的泛型就Any
        //3. 遍历方式一样
        var arr02 = Array(1, 3, "xx")
        arr02(1) = "xx"
        for (i <- arr02) {
            println(i)
        }
        //可使用传统的方式遍历，使用下标的方式遍历
        for (index <- 0 until arr02.length) {
            printf("arr02[%d]=%s", index , arr02(index) + "\t")
        }
    }
}
```



# ArrayBuffer

- 变长数组

  

## 定义

```scala
//定义/声明
val arr2 = ArrayBuffer[Int]()
//追加值/元素
arr2.append(7)
//重新赋值
arr2(0) = 7
```

- 示例

```scala
import scala.collection.mutable.ArrayBuffer

object ArrayBufferDemo01 {
    def main(args: Array[String]): Unit = {
        //创建ArrayBuffer
        val arr01 = ArrayBuffer[Any](3, 2, 5)

        //访问，查询
        //通过下标访问元素
        println("arr01(1)=" + arr01(1)) // arr01(1) = 2
        //遍历
        for (i <- arr01) {
            println(i)
        }
        println(arr01.length) //3
        println("arr01.hash=" + arr01.hashCode())

        //修改 [修改值，动态增加]
        //使用append 追加数据 ,append支持可变参数
        //可以理解成java的数组的扩容
        arr01.append(90.0,13) // (3,2,5,90.0,13)
        println("arr01.hash=" + arr01.hashCode())

        arr01(1) = 89 //修改 (3,89,5,90.0,13)
        println("--------------------------")
        for (i <- arr01) {
            println(i)
        }

        //删除...
        //删除,是根据下标来说
        arr01.remove(0)  // (89,5,90.0,13)
        println("--------删除后的元素遍历---------------")
        for (i <- arr01) {
            println(i)
        }
        println("最新的长度=" + arr01.length) // 4
    }
}
```

- ArrayBuffer是变长数组，类似java的ArrayList

- `val arr2 = ArrayBuffer[Int]()` 使用的apply方法构建对象

- `def append(elems: A*) { appendAll(elems) }` 接收的是可变参数

- 每append一次，arr在底层会重新分配空间，进行扩容，arr2的内存地址会发生变化，也就成为新的ArrayBuffer

  - 即使是val定义，arr也会重新分配空间

    

# Array和ArrayBuffer转换

- 说明
  - 在开发中，我们可能使用对定长数组和变长数组，进行转换
    - arr1.toBuffer //定长数组转可变数组
      - 返回结果是一个可变数组， arr1本身没有变化
    - arr2.toArray //可变数组转定长数组
      - 返回结果是一个定长数组， arr2本身没有变化

```scala
import scala.collection.mutable.ArrayBuffer

object Array22ArrayBuffer {
    def main(args: Array[String]): Unit = {

        val arr2 = ArrayBuffer[Int]()
        // 追加值
        arr2.append(1, 2, 3)
        println(arr2)

        //说明
        //1. arr2.toArray 调用 arr2的方法 toArray
        //2. 将 ArrayBuffer ---> Array
        //3. arr2本身没有任何变化
        val newArr = arr2.toArray
        println(newArr)

        //说明
        //1. newArr.toBuffer 是把 Array->ArrayBuffer
        //2. 底层的实现
        /*
     override def toBuffer[A1 >: A]: mutable.Buffer[A1] = {
    val result = new mutable.ArrayBuffer[A1](size)
    copyToBuffer(result)
    result
  }
     */
        //3. newArr本身没变化
        val newArr2 = newArr.toBuffer
        newArr2.append(123)
        println(newArr2)
    }
}
```



# 多维数组

```scala
// 定义
val arr = Array.ofDim[Double](3,4)
// 说明：二维数组中有三个一维数组，
// 每个一维数组中有四个元素
// 赋值
arr(1)(1) = 11.11
```

```scala
object MultiplyArray {
    def main(args: Array[String]): Unit = {
        //创建
        val arr = Array.ofDim[Int](3, 4)

        //遍历
        for (item <- arr) { //取出二维数组的各个元素（一维数组）
            for (item2 <- item) { // 元素（一维数组） 遍历
                print(item2 + "\t")
            }
            println()
        }
        //指定取出
        println(arr(1)(1)) // 0
        //修改值
        arr(1)(1) = 100
        //遍历
        println("=====================")
        for (item <- arr) { //取出二维数组的各个元素（一维数组）
            for (item2 <- item) { // 元素（一维数组） 遍历
                print(item2 + "\t")
            }
            println()
        }
        //使用传统的下标的方式来进行遍历
        println("===================")
        for (i <- 0 to arr.length - 1) { //先对
            for (j <- 0 to arr(i).length - 1) {
                printf("arr[%d][%d]=%d\t", i, j, arr(i)(j))
            }
            println()
        }
    }
}
```



# scala数组与java数组互转



## scala数组转java的List

```scala
import scala.collection.mutable.ArrayBuffer

object ArrayBuffer2JavaList {
    def main(args: Array[String]): Unit = {
        // Scala集合和Java集合互相转换
        val arr = ArrayBuffer("1", "2", "3")
        /*
        implicit def bufferAsJavaList[A](b : scala.collection.mutable.Buffer[A]) : java.util.List[A] = { /* compiled code */ }
    */
    import scala.collection.JavaConversions.bufferAsJavaList
    //对象 ProcessBuilder ， 因为 这里使用到上面的  bufferAsJavaList
    val javaArr = new ProcessBuilder(arr) //为什么可以这样使用?
    // 这里arrList 就是java中的List
    val arrList = javaArr.command()

    println(arrList) //输出 [1, 2, 3]
}
}
```

- 使用trait来实现的参数多态

```scala
trait MyTrait01 {}
class A extends MyTrait01 {}
object B {
    def test(m: MyTrait01): Unit = {
        println("b ok..")
    }
}
//明确一个知识点
//当一个类继承了一个trait
//那么该类的实例，就可以传递给这个trait引用
val a01 = new A
B.test(a01)
```



## java的List转scala数组

```scala
//java的List 转成 scala的 ArrayBuffer
//说明
//1. asScalaBuffer 是一个隐式函数
/*
    implicit def asScalaBuffer[A](l : java.util.List[A]) : scala.collection.mutable.Buffer[A] = { /* compiled code */ }
*/
import scala.collection.JavaConversions.asScalaBuffer
import scala.collection.mutable
// java.util.List ==> Buffer
val scalaArr: mutable.Buffer[String] = arrList
scalaArr.append("jack")
scalaArr.append("tom")
scalaArr.remove(0)
println(scalaArr) // (2,3,jack,tom)
```



# Tuple

- 元组可以理解为一个容器
- 存放各种相同或不同类型的数据

- 将多个无关的数据封装为一个整体，称为元组,
- 特点灵活
- 对数据没有过多的约束
- ==元组中最多有22个元素==



## 创建

```scala
//创建
//说明 1. tuple1 就是一个Tuple 类型是Tuple5
//简单说明: 为了高效的操作元组 ， 编译器根据元素的个数不同，对应不同的元组类型
//分别 Tuple1----Tuple22

val tuple1 = (1, 2, 3, "hello", 4)
println(tuple1)
```

- t1 的类型是 Tuple5类 是scala特有的类型

- t1 的类型取决于 t1 **后面有多少个元素**, 有对应关系
  - 如 4个元素=>Tuple4

```scala
final case class Tuple5[+T1, +T2, +T3, +T4, +T5](_1: T1, _2: T2, _3: T3, _4: T4, _5: T5)
extends Product5[T1, T2, T3, T4, T5]
{
    override def toString() = "(" + _1 + "," + _2 + "," + _3 + "," + _4 + "," + _5 + ")"
}
```

- 元组中最大只能有22个元素 即 Tuple1...Tuple22



## 元素访问

- 采用顺序号（_顺序号）
- 通过索引（productElement）访问
  - 访问元组的第一个元素，从0开始

```scala
println("==================访问元组=========================")
//访问元组
val t1 = (1, "a", "b", true, 2)
println(t1._1) // 1 //访问元组的第一个元素 ，从1开始

/*
	override def productElement(n: Int) = n match {
    case 0 => _1
    case 1 => _2
    case 2 => _3
    case 3 => _4
    case 4 => _5
    case _ => throw new IndexOutOfBoundsException(n.toString())
 }
*/
println(t1.productElement(0))
```



## 遍历

- Tuple是一个整体，遍历需要调其迭代器

```scala
println("==================遍历元组=========================")
//遍历元组, 元组的遍历需要使用到迭代器
for (item <- t1.productIterator) {
    println("item=" + item)
}
```



# List

- Scala中的List 和Java List 不一样
  - Java中List是一个接口，真正存放数据是ArrayList
  - Scala的List可以直接存放数据，就是一个object
    - 默认情况下Scala的List是不可变的
- List属于序列Seq

```scala
val List = scala.collection.immutable.List
object List extends SeqFactory[List]
```





## 创建

```scala
object ListDemo01 {
    def main(args: Array[String]): Unit = {
        //说明
        //1. 在默认情况下 List 是scala.collection.immutable.List,即不可变
        //2. 在scala中,List就是不可变的，如需要使用可变的List,则使用ListBuffer
        //3. List 在 package object scala 做了 val List = scala.collection.immutable.List
        //4. val Nil = scala.collection.immutable.Nil // List()

        val list01 = List(1, 2, 3) //创建时，直接分配元素
        println(list01)
        val list02 = Nil  //空集合
        println(list02)

    }
}
```

- List默认为不可变的集合
- List 在 scala包对象声明的
  - 不需要引入其它包也可使用

```scala
val List = scala.collection.immutable.List
```

- List 中可以放任何数据类型
  - 如 arr1的类型为 List[Any]

- 如果希望得到一个空列表，使用==Nil对象==

  - 在 scala包对象声明的，不需要引入其它包也可使用

    ```scala
    val Nil = scala.collection.immutable.Nil
    ```

    ​	

## 追加

- 向列表中增加元素会返回新的列表/集合对象
- 注意：Scala中List元素的追加形式非常独特，和Java不一样

```scala
println("-------------list追加元素后的效果-----------------")
//通过 :+ 和 +: 给list追加元素(本身的集合并没有变化)
var list1 = List(1, 2, 3, "abc")
// :+运算符表示在列表的最后增加数据
val list2 = list1 :+ 4 // (1,2,3,"abc", 4)
println(list1) //list1没有变化 (1, 2, 3, "abc"),说明list1还是不可变
println(list2) //新的列表结果是 [1, 2, 3, "abc", 4]

val list3 = 10 +: list1 // (10,1, 2, 3, "abc")
println("list3=" + list3)
```

- 符号::表示向集合中 新建集合添加元素
  - 运算时，**集合对象一定要放置在最右边**
  - 运算规则从右向左
  - **::: 运算符是将集合中的每一个元素加入到集合中**去

```scala
val list4 = List(1, 2, 3, "abc")
//说明 val list5 = 4 :: 5 :: 6 :: list4 :: Nil 步骤
//1. List()
//2. List(List(1, 2, 3, "abc"))
//3. List(6,List(1, 2, 3, "abc"))
//4. List(5,6,List(1, 2, 3, "abc"))
//5. List(4,5,6,List(1, 2, 3, "abc"))
val list5 = 4 :: 5 :: 6 :: list4 :: Nil
println("list5=" + list5)

//说明 val list6 = 4 :: 5 :: 6 :: list4 ::: Nil 步骤
//1. List()
//2. List(1, 2, 3, "abc")
//3. List(6,1, 2, 3, "abc")
//4. List(5,6,1, 2, 3, "abc")
//5. List(4,5,6,1, 2, 3, "abc")
val list6 = 4 :: 5 :: 6 :: list4 ::: Nil
println("list6=" + list6)
```

- 练习

```scala
val list1 = List(1,2,3,"abc")
val list2 = 4::5::6::list1
println(list2) // 4,5,6,1,2,3,"abc"

val list1 = List(1,2,3,"abc")
val list2 = 4::5::6::list1::9
println(list2) // 错误

val list1 = List(1,2,3,"abc")
val list2 = 4::5::6:::list1:::Nil
println(list2) // 错误，:::左右必须都为集合

val list1 = List(1,2,3,"abc")
val list2 = 4::5::6::list1:::list1:::Nill
println(list2) // 4,5,6,1,2,3,"abc",1,2,3,"abc"
```



# ListBuffer

- 可变的list集合，可添加/删除元素
- ListBuffer属于序列

```scala
//追一下继承关系即可
Seq var listBuffer = ListBuffer(1,2)
```

```scala
import scala.collection.mutable.ListBuffer

object ListBufferDemo01 {
    def main(args: Array[String]): Unit = {
        //创建ListBuffer
        val lst0 = ListBuffer[Int](1, 2, 3)

        //如何访问
        println("lst0(2)=" + lst0(2)) // 输出 lst0(2)= 3
        for (item <- lst0) { // 遍历，是有序
            println("item=" + item)
        }

        //动态的增加元素，lst1就会变化, 增加一个一个的元素
        val lst1 = new ListBuffer[Int] //空的ListBuffer
        lst1 += 4 // lst1 (4)
        lst1.append(5) // list1(4,5)

        lst0 ++= lst1 // lst0 (1, 2, 3,4,5)

        println("lst0=" + lst0)

        val lst2 = lst0 ++ lst1 // lst2(1, 2, 3,4,5,4,5)
        println("lst2=" + lst2)

        val lst3 = lst0 :+ 5 // lst0 不变 lst3(1, 2, 3,4,5,5)
        println("lst3=" + lst3)

        println("=====删除=======")
        println("lst1=" + lst1)
        lst1.remove(1) // 表示将下标为1的元素删除
        for (item <- lst1) {
            println("item=" + item) //4
        }
    }
}
```



# Queue

- 队列是一个**有序列表**，在底层可以用**数组**或是**链表**来实现。

- 其输入和输出要遵循**先入先出的原则**
  - 先存入队列的数据，要先取出
  - 后存入的要后取

- 在Scala中，由设计者直接给我们提供队列类型Queue使用

- 在scala中
  -  scala.collection.mutable.Queue
  - scala.collection.immutable.Queue
  - 一般来说在开发中通常使用可变集合中的队列



## 创建

```scala
//创建队列
val q1 = new mutable.Queue[Int]
println(q1)
```



## 追加

```scala
//给队列增加元素
q1 += 9 // (9)
println("q1=" + q1) // (9)
q1 ++= List(4,5,7) // 默认值直接加在队列后面
println("q1=" + q1) //(9,4,5,7)

//q1 += List(10,0) // 表示将List(10,0) 作为一个元素加入到队列中,
```



## 入队/出队

```scala
//dequeue 从队列的头部取出元素 q1本身会变
val queueElement = q1.dequeue()
println("queueElement=" + queueElement + "q1="+q1)

//enQueue 入队列，默认是从队列的尾部加入. Redis
q1.enqueue(100,10,100,888)
println("q1=" + q1) // Queue(4, 5, 7, 100,10,100,888)
```



## 访问

```scala
println("============Queue-返回队列的元素=================")
//队列 Queue-返回队列的元素

//1. 获取队列的第一个元素
println(q1.head) // 4, 对q1没有任何影响
//2. 获取队列的最后一个元素
println(q1.last) // 888, 对q1没有任何影响
//3. 取出队尾的数据 ,即：返回除了第一个以外剩余的元素，可以级联使用
println(q1.tail) // (5, 7, 100,10,100,888)
println(q1.tail.tail.tail.tail) // (10,100,888)
```



# Map

- java中HashMap 是一个**散列表(数组+链表**)
  - 存储的内容是键值对(**key-value)**映射
  - Java中的HashMap是**无序的**，**key不能重复**

```java
import java.util.HashMap;

public class JavaHashMap {
    public static void main(String[] args) {

        HashMap<String,Integer> hm = new HashMap();
        hm.put("no1", 100);
        hm.put("no2", 200);
        hm.put("no3", 300);
        hm.put("no4", 400);
        hm.put("no1", 500); //更新

        System.out.println(hm);//无序的
        System.out.println(hm.get("no2"));
    }
}
```

- scala中Map 和Java类似是一**个散列表**
  - 存储的内容是键值对(key-value)映射
  - Scala中**不可变的Map是有序的**，**可变的Map是无序的**
  - 可变Map (scala.collection.mutable.Map)
  - 不可变Map(scala.collection.immutable.Map) 



## 构建



### 不可变Map

- Scala中的不可变Map是有序，构建Map中的元素底层是Tuple2类型

```scala
object MapDemo01 {
    def main(args: Array[String]): Unit = {
        //1.默认Map是 immutable.Map
        //2.key-value 类型支持Any
        //3.在Map的底层，每对key-value是Tuple2
        //4.从输出的结果看到，输出顺序和声明顺序一致
        val map1 = Map("Alice" -> 10, "Bob" -> 20, "Kotlin" -> "北京")
        println(map1)
    }
}
```



### 可变Map

```scala
//方式2-构造可变映射
//1.从输出的结果看到，可变的map输出顺序和声明顺序不一致
val map2 = mutable.Map("Alice" -> 10, "Bob" -> 20, "Kotlin" -> "北京")
println(map2)
```



### 空Map

```scala
val map3 = new scala.collection.mutable.HashMap[String, Int]
println(map3)
```



### 对偶元组

- 创建包含键值对的二元组， 和第一种方式等价，只是形式上不同而已

- 对偶元组只含有两个数据的元组

```scala
//方式4-对偶元组
val map4 = mutable.Map(("Alice" , 10), ("Bob" , 20), ("Kotlin" , "北京"))
println("map4=" + map4)
```



## 访问



### map(key)

- 如果key存在，则返回对应的值

- 如果key不存在，则抛出异常[java.util.NoSuchElementException]

- 在Java中,如果key不存在则返回null

```scala
//方式1-使用map(key)
println(map4("Alice")) // 10
//抛出异常（java.util.NoSuchElementException: key not found:）
//println(map4("Alice~"))
```



### contains

- 使用contains方法检查是否存在key
  - 返回Boolean
  - 如果key存在，则返回true
  - 如果key不存在，则返回false

```scala
//方式2-使用contains方法检查是否存在key
if (map4.contains("Alice")) {
    println("key存在，值=" + map4("Alice"))
} else {
    println("key不存在:)")
}
```



### map.get(key).get

- 通过 映射.get(键) 这样的调用返回一个Option对象，要么是Some，要么是None
  - map.get方法会将数据进行包装
  - 如果 map.get(key) key存在返回some,如果key不存在，则返回None
  - 如果 map.get(key).get  key存在，返回key对应的值,否则，抛出异常 java.util.NoSuchElementException: None.get

```scala
//方式3 方式3-使用map.get(key).get取值
//1. 如果key存在 map.get(key) 就会返回Some(值)  ,然后Some(值).get就可以取出
//2. 如果key不存在 map.get(key) 就会返回None

println(map4.get("Alice").get)
//println(map4.get("Alice~").get)  // 抛出异常
```



### map4.getOrElse()

- 如果key存在，返回key对应的值

- 如果key不存在，返回默认值
  - 在java中底层有很多类似的操作

```scala
//方式4-使用map4.getOrElse()取值
println(map4.getOrElse("Alice~~~","默认的值 鱼 <・)))><<"))
```



### 如何选择取值的方式

- 如果确定map有这个key ,则应当使用map(key), 速度快

- 如果不能确定map是否有key , 而且有不同的业务逻辑，使用map.contains() 先判断在加入逻辑 

- 如果只是简单的希望得到一个值，使用map4.getOrElse("ip","127.0.0.1")



## 更新

- map 是可变的，才能修改，否则报错

- **key存在，修改**对应的值
- **key不存在，添加**一个key-val

```scala
val map5 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )
map5("A") = 20 //增加
println("map5=" + map5)
```



## 添加

- 说明: 当增加一个key-value ,如果key存在就是更新，如果不存在，这是添加

```scala
val map1 = mutable.Map(("A",1),("B","北京"),("C",3))
map1 += ("D"->4)
map1 += ("B"->50)
println(map1)

// 增加多个元素
val map2 = map1 + ("E"->1,"F"->3)
map1 += ("E"->1,"F"->3)
```



## 删除

```scala
map5 -= ("A","B","AAA") //
println("map5=" + map5)
```

- "A","B" 就是要删除的key, 可以写多个.

- 如果key存在，就删除，如果key不存在，也不会报错.



## 遍历

对map的元素(元组Tuple2对象 )进行遍历的方式很多

```scala
val map1 = mutable.Map( ("A", 1), ("B", "北京"), ("C", 3) )

for ((k, v) <- map1) println(k + " is mapped to " + v)
for (k <- map1.keys) println(k)
for (v <- map1.values) println(v)
// 每遍历一次，返回的元素是Tuple2
// 取出的时候，可以按照元组的方式来取
for(t <- map1) println(t._1+"->"+t._2)
```



# Set

- 集是**不重复元素的结合**。集**不保留顺序**
- 默认是以**哈希**集实现

- java中
  - HashSet是实现Set<E>接口的一个实体类，数据是以哈希表的形式存放的，里面的不能包含重复数据
  - Set接口是一种不包含重复元素的 collection
  - HashSet中的数据也是没有顺序的

```java
import java.util.HashSet;

public class JavaHashSet {
    public static void main(String[] args) {
        //java中的Set的元素 没有顺序，不能重复
        HashSet hs = new HashSet<String>();
        hs.add("jack");
        hs.add("tom");
        hs.add("jack");
        hs.add("jack2");
        System.out.println(hs);
    }
}
```

- scala中
  - 默认情况下Scala 使用的是不可变集合
  - 如果使用可变集合需引用 scala.collection.mutable.Set 包



## 创建

```scala
import scala.collection.mutable
object SetDemo01 {
    def main(args: Array[String]): Unit = {
        val set = Set(1, 2, 3) //不可变
        println(set)
        val set2 = mutable.Set(1,2,"hello") //可以变
        println("set2" + set2)
    }
}
```



## 可变集合添加

- 如果添加的对象已经存在，则不会重复添加，也不会报错

```scala
mutableSet.add(4) //方式1
mutableSet += 6  //方式2
mutableSet.+=(5) //方式3
```



## 可变集合删除

```scala
val set02 = mutable.Set(1,2,4,"abc")
set02 -= 2 // 操作符形式
set02.remove("abc") // 方法的形式，scala的Set可以直接删除值
println(set02)
```

- 说明：如果删除的对象不存在，则不生效，也不会报错



## 遍历

```scala
val set02 = mutable.Set(1, 2, 4, "abc")
for(x <- set02) {
    println(x)
}
```



## 其他操作

| 方法                                     | 描述                                                 |
| ---------------------------------------- | ---------------------------------------------------- |
| def +(elem: A): Set[A]                   | 为集合添加新元素，并创建一个新的集合，除非元素已存在 |
| def -(elem: A): Set[A]                   | 移除集合中的元素，并创建一个新的集合                 |
| def contains(elem: A): Boolean           | 如果元素在集合中存在，返回 true，否则返回 false。    |
| def &(that: Set[A]): Set[A]              | 返回两个集合的交集                                   |
| def &~(that: Set[A]): Set[A]             | 返回两个集合的差集                                   |
| def ++(elems: A): Set[A]                 | 合并两个集合                                         |
| def drop(n: Int): Set[A]]                | 返回丢弃前n个元素新集合                              |
| def dropRight(n: Int): Set[A]            | 返回丢弃最后n个元素新集合                            |
| def dropWhile(p: (A) => Boolean): Set[A] | 从左向右丢弃元素，直到条件p不成立                    |
| def max: A                               | ==查找最大元素==                                     |
| def min: A                               | ==查找最小元素==                                     |
| def take(n: Int): Set[A]                 | 返回前 n 个元素                                      |

