# match

- Scala中的模式匹配类似于Java中的switch语法，但更加强大
- 模式匹配语法中
  - 采用match关键字声明
  - 每个分支采用case关键字进行声明
  - 匹配时从第一个case分支开始
    - 匹配成功，则执行对应的逻辑代码
    - 匹配不成功，继续执行下一个分支进行判断
    - 所有case都不匹配则执行case _ 分支
      - 类似于Java中default语句

- 示例

```scala
def main(args: Array[String]): Unit = {
    val oper = '-'
    val n1 = 20
    val n2 = 10
    var res = 0
    oper match {
        case '+' => res = n1 + n2
        case '-' => res = n1 - n2
        case '*' => res = n1 * n2
        case '/' => res = n1 / n2
        case _ => println("oper error")
    }
    println("res=" + res)
}
```

- 说明
  - 如所有case都不匹配，又没有写case _ 分支，那么会抛出MatchError
  - 每个case中，不用break语句，自动中断case
  - 可在match中使用其它类型，而不仅仅是字符
  - => 等价于 java swtich 的 :
  - => 后面的代码块到下一个 case， 是作为一个整体执行，可使用{} 扩起来



# 守卫

- 要表达匹配某个范围的数据，可在模式匹配中增加条件守卫

```scala
def main(args: Array[String]): Unit = {
    // 对该字符串进行遍历
    for(ch <- "+-3!") {
        ch match {
            case '+' => println("匹配 +")
            case '-' => println("匹配 -")
            case _ if ch.toString.equals("3") => println("匹配到字符 3")
            case _ if (ch > 100 || ch < 1) => println("匹配字符范围")
            case _ => println("error")
            case _ => println("error2")
        }
    }
}
// 结果
//匹配 +
//匹配 -
//匹配到字符 3
//error
```

- 如果 case 后有 条件守卫即 if 这时的 _ ==不是表示默认匹配==
  - 表示==忽略==传入的 ch
- 可有多个默认匹配，但后面的默认匹配无效，编译器没有报错



# 模式中的变量

- 在case关键字后跟变量名，那么match前表达式的值会赋给那个变量

```scala
def main(args: Array[String]): Unit = {
    val ch = 'x'
    ch match {
        case '+' => println("x ...")
        case myChar => println("char-- "+myChar)
        case _ => println("error")
    }
}
// result: char-- x
```

- 模式的返回值
  - match是一个表达式，有返回值
  - 返回值是匹配到的代码块的最后一句话的值

```scala
def main(args: Array[String]): Unit = {
    val ch = 'x'
    val re = ch match {
        case '+' => println("x ...")
        case myChar => "re" + myChar
        case _ => println("error")
    }
    println(re)
}
// result: rex
// 如果都没有匹配，此处的返回值是()
```



# 类型匹配

- 匹配**对象的任意类型**，避免了使用**isInstanceOf**和**asInstanceOf**方法

```scala
def main(args: Array[String]): Unit = {
    val a = 5
    val obj = if (a == 1) 1
    else if (a == 2) "2"
    else if (a == 3) BigInt(3)
    else if (a == 4) Map("aa" -> 1)
    else if (a == 5) Map(1 -> "aa")
    else if (a == 6) Array(1, 2, 3)
    else if (a == 7) Array("aa", 1)
    else if (a == 8) Array("aa")

    // obj 在上下文中必须要有可能为如下类型，否则会报错
    val re = obj match {
        case a: Int => a
        case b: Map[String,Int] => "Map[String,Int]"
        case c: Map[Int,String] => "Map[Int,String]"
        case _: Array[String] => "Array[String]"
        case e: BigInt => Int.MaxValue
        case _ => "error"
    }
    println(re)
}
```

- Map[String, Int] 和Map[Int, String]是两种不同的类型，其它类推
- 在进行类型匹配时，编译器会预先检测是否有可能的匹配，如果没有则报错
- 如果 case _ 出现在match 中间，表示隐藏变量名
  - 即不使用
  - 不表示默认匹配



# 匹配数组 Array

- Array(0) 匹配只有一个元素且为0的数组
- Array(x,y) 匹配数组有两个元素，并将==两个元素赋值为x和y==
  - 可依次类推Array(x,y,z) 匹配数组有3个元素的等
- Array(0,_*) 匹配数组以0开始

```scala
import scala.collection.mutable.ArrayBuffer

object Test01{
    def main(args: Array[String]): Unit = {
        val arrs = Array(Array(0), Array(1, 0), Array(0, 1, 0),
                         Array(1, 1, 0), Array(1, 1, 0, 1))
        for (item <- arrs){
            val re = item match {
                case Array(0) => "0"
                case Array(x,y) => ArrayBuffer(y,x)
                case Array(0,_*) => "0 开头的数组"
                case _ => "error"
            }
            println(re)
        }
    }
}
// result:
//0
//ArrayBuffer(0, 1)
//0 开头的数组
//error
//error
```



# 匹配列表 List

```scala
def main(args: Array[String]): Unit = {
    val list = Array(List(0), List(1, 0), List(88), List(0, 0, 0),List(1, 0, 0))
    for(item <- list){
        val re = item match {
            case 0::Nil => "0"
            case x::y::Nil => x+"-"+y
            case 0::tail => "0.."
            case x::tail => x
            case _ => "error"
        }
        println(re)
    }
}
// result：
//0
//1-0
//88
//0..
//1
```



# 匹配元组

```scala
def main(args: Array[String]): Unit = {
    val tuple = Array((0, 1), (1, 0), (10, 30), (1, 1), (1, 0, 2))
    for(item <- tuple){
        val re = item match {
            case (0,_) => "0,.."
            case (x,0) => x + ",0"
            case (x,y) => (y,x)
            case _ => "error"
        }
        println(re)
    }
}
// result:
//0,..
//1,0
//(30,10)
//(1,1)
//error
```



# 对象匹配

- case中对象的unapply方法(对象提取器)返回Some集合则为匹配成功

- 返回None集合则为匹配失败

