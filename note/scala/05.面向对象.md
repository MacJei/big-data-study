# 类与对象

- 问题的描述看一个养猫猫问题

张老太养了只猫猫:一只名字叫小白,今年3岁,白色。还有一只叫小花,今年10岁,花色。请编写一个程序，当用户输入小猫的名字时，就显示该猫的名字，年龄，颜色。如果用户输入的小猫名错误，则显示 张老太没有这只猫猫。

 

- 问题

猫有三个属性，类型不一样.如果使用普通的变量就不好管理使用一种新的数据类型((1) 可以管理多个不同类型的数据 [属性]) (2) 可以对属性进行操作-方法 ，因此类与对象



## Scala面向对象

- Java是面向对象的编程语言，由于历史原因，Java中还存在着非面向对象的内容
  - 基本类型 ，null，静态方法等

- Scala语言来自于Java，所以天生就是面向对象的语言，而且Scala是纯粹的面向对象的语言，即在Scala中，一切皆为对象

```scala
object CatDemo {
    def main(args: Array[String]): Unit = {

        //创建一只猫
        val cat = new Cat
        //给猫的属性赋值

        //说明
        //1. cat.name = "小白" 其实不是直接访问属性，而是  cat.name_$eq("小白")
        //2. cat.name 等价于 cat.name()
        cat.name = "小白" //等价
        cat.age = 10
        cat.color = "白色"
        println("ok~")
        printf("\n小猫的信息如下: %s %d %s", cat.name, cat.age, cat.color)
    }
}

//定义一个类Cat
//一个class Cat 对应的字节码文件只有一个 Cat.class ,默认是public
class Cat {
    //定义/声明三个属性
    //说明
    //1. 当我们声明了 var name :String时, 在底层对应 private name
    //2. 同时会生成 两个public方法 name() <=类似=> getter  public name_$eq() => setter
    var name: String = "" //给初始值
    var age: Int = _ // _ 表示给age 一个默认的值 ，如果Int 默认就是0
    var color: String = _ // _ 给 color 默认值，如果String ,默认是就是""
}

/* 反编译查看
public class Cat
{
  private String name = "";
  private int age;
  private String color;

  public String name()
  {
    return this.name; }
  public void name_$eq(String x$1) { this.name = x$1; }
  public int age() { return this.age; }
  public void age_$eq(int x$1) { this.age = x$1; }
  public String color() { return this.color; }
  public void color_$eq(String x$1) { this.color = x$1; }

}
```



## 类和对象的区别和联系

- 类是抽象的，概念的，代表一类事物,比如人类,猫类.
- 对象是具体的，实际的，代表一个具体事物
- 类是对象的模板，对象是类的一个个体，对应一个实例
- Scala中类和对象的区别和联系 和 Java是一样的



## 定义类

- scala语法中，类并不声明为public
  - 默认public
  - 手动添加public报错
  - 所有这些类都具有公有可见性(即默认就是public),[修饰符在后面再详解].

- 一个Scala源文件可以包含多个类.,而且默认都是public



## 属性

- 属性是类的一个组成部分，一般是值数据类型,也可是引用类型
  - 如前面定义猫类 的 age  就是属性

```scala
class Dog{
    var name = "jack"
    var lover = new Fish
}
class Fish{
}
```



## 成员变量

- 属性的定义语法同变量，示例：[访问修饰符] var 属性名称 [：类型] = 属性值

- 属性的定义类型可以为任意类型，包含值类型或引用类型[案例演示]

- Scala中声明一个属性,必须显示的初始化，然后根据初始化数据的类型自动推断，属性类型可以省略(这点和Java不同)。[案例演示] 	

- 如果赋值为null,则一定要加类型，因为不加类型, 那么该属性的类型就是Null类型.

- 如果在定义属性时，暂时不赋值，也可以使用符号_(下划线)，让系统分配默认值.

| **类型**            | **_** **对应的值** |
| ------------------- | ------------------ |
| Byte Short Int Long | 0                  |
| Float Double        | 0.0                |
| String 和 引用类型  | null               |
| Boolean             | false              |

```scala
class A {
    var var1 :String = _  // null
    var var2 :Byte = _  // 0
    var var3 :Double = _  //0.0
    var var4 :Boolean = _  //false
}
```

- 不同对象的属性是独立，互不影响，一个对象对属性的更改，不影响另外一个



## 创建对象

- 基本语法
  - val | var 对象名 [：类型]  = new 类型()
- 说明
  - 如果不希望改变对象的引用(即：内存地址), 应该声明为val 性质的，否则声明为var
  - 推荐使用val 一般在程序中只是改变对象属性的值，而不是改变对象的引用
  - 在声明对象变量时，可根据创建对象的类型自动推断，所以类型声明可以省略，**但当类型和后面new 对象类型有继承关系即多态时**，就必须写

```scala
object CreateObj {
    def main(args: Array[String]): Unit = {
        val emp = new Emp // emp 类型就是Emp
        //如果我们希望将子类对象，交给父类的引用，这时就需要写上类型
        val emp2: Person = new Emp

    }
}

class Person {

}

class Emp extends Person {
}
```



## 类和对象的内存分配机制

```scala
object MemState {
    def main(args: Array[String]): Unit = {
        val p1 = new Person2
        p1.name = "jack"
        p1.age = 10

        val p2 = p1
        println(p1 == p2) // true
        p1.name = "tom"
        println("p2.name=" + p2.name)
    }
}

class Person2 {
    var name = ""
    var age: Int  = _ //如果是用 _ 方式给默认值，则属性必须指定类型
}
```

![img](../img/scala/17.png)



# 方法

- Scala中的方法其实就是函数，声明规则请参考函数式编程中的函数声明

```scala
def 方法名(参数列表) [：返回值类型] = { 
	方法体
}
```

```scala
object MethodDemo01 {
    def main(args: Array[String]): Unit = {
       
        val dog = new Dog
        println(dog.cal(10, 20))
    }
}

class Dog {
    private var sal: Double = _
    var food: String = _

    //方法
    def cal(n1: Int, n2: Int): Int = {
        return n1 + n2
    }
}
```

- 练习

```scala
object MethodDemo02 {
    def main(args: Array[String]): Unit = {
        /*
    编写类(MethodExec)，编程一个方法，方法不需要参数，在方法中打印一个
10*8 的矩形，在main方法中调用该方法。
     */
        val m = new MethodExec
        m.printRect()
        /*
    修改上一个程序，编写一个方法中，方法不需要参数，计算该矩形的面积，并将其作为方法返回值。在main方法中调用该方法，接收返回的面积值并打印(结果保留小数点2位)
    分析
    1. 我们的矩形的长和宽需要设计成属性
     */

        m.width = 2.1
        m.len = 3.4
        println("面积=" + m.area())
    }
}

class MethodExec {
    //属性
    var len = 0.0
    var width = 0.0

    def printRect(): Unit = {
        for (i <- 0 until 10) {
            for (j <- 0 until 8) {
                print("*")
            }
            println()
        }
    }

    //计算面积的方法
    def area(): Double = {
        (this.len * this.width).formatted("%.2f").toDouble
    }
}
```

```scala
object DogCaseTest {
    def main(args: Array[String]): Unit = {
        val dog = new Dog
        dog.name = "tomcat"
        dog.age = 2
        dog.weigth = 6
        println(dog.say())
    }
}

/*
小狗案例

编写一个Dog类，包含name(String)、age(Int)、weight(Double)属性
类中声明一个say方法，返回String类型，方法返回信息中包含所有属性值。

在另一个DogCaseTest类中的main方法中，创建Dog对象，并访问say方法和所有
属性，将调用结果打印输出。

 */
class Dog{
    var name = ""
    var age = 0
    var weigth = 0.0
    def say(): String = {
        "小狗信息如下: name=" + this.name + "\t age=" +
        this.age + " weight=" + this.weigth
    }
}
```



# 构造器

- 前面我们在创建Person的对象时，是先把一个对象创建好后，再给他的年龄和姓名属性赋值，如果现在我要求，在创**建人类的对象时，就直接指定这个对象的年龄和姓名**，该怎么做? 这时就可以使用构造方法/构造器



## java构造器

```java
[修饰符] 方法名(参数列表){
	构造方法体
}
```

- 特点
  - 在Java中一个类可以定义多个不同的构造方法，构造方法重载
  - 如果程序员没有定义构造方法，系统会自动给类生成一个默认无参构造方法
    - 默认构造器
    - 如 Person (){}
  - 一旦定义了自己的构造方法（构造器）,默认的构造方法就覆盖
    - 不能再使用默认的无参构造方法，除非显示的定义一下
      - 即Person(){};

- 在前面定义的Person类中添加两个构造器：
  - 第一个无参构造器
    - 利用构造器设置所有人的age属性初始值都为18
  - 第二个带name和age两个参数的构造器
    - 使得每次创建Person对象的同时初始化对象的age属性值和name属性值

```java
class Person{
    public String name;
    public int age;
    public String getInfo(){
        return name+"\t"+age;
    }
    public Person(){
        age = 18;
    }
    public Person(String name,int age){
        this.name = name;
        this.age = age;
    }
}
```



## scala构造器

- 和Java一样，Scala构造对象也需要调用构造方法，并且可以有任意多个构造方法
  - 即scala中构造器也支持重载

- Scala类的构造器包括

  - 主构造器
  - 辅助构造器

  

### 基本语法

```scala
class 类名(形参列表) {  // 主构造器
    // 类体
    def  this(形参列表) {  // 辅助构造器
    }
    def  this(形参列表) {  //辅助构造器可以有多个...
    }
} 
```

- 辅助构造器 函数的名称this, 可以有多个，编译器通过不同参数来区分
- 示例

```scala
object ConDemo01 {
    def main(args: Array[String]): Unit = {
        //    val p1 = new Person("jack", 20)
        //    println(p1)
        //
        //    val a = new A
        //    val a2 = new A()

        //下面这句话就会调用def this(name:String)
        val p2 = new Person("tom")
        println(p2)
    }
}

//构造器的快速入门
//创建Person对象的同时初始化对象的age属性值和name属性值
class Person(inName:String,inAge:Int) {
    var name: String = inName
    var age: Int = inAge
    age += 10
    println("~~~~~~~~~~")

    //重写了toString，便于输出对象的信息
    override def toString: String = {
        "name=" + this.name + "\t age" + this.age
    }

    println("ok~~~~~")
    println("age=" + age)

    def this(name:String) {
        //辅助构造器，必须在第一行显式调用主构造器(可以是直接，也可以是间接)
        this("jack", 10)
        //this
        this.name = name //重新赋值
    }
}

class A() {

}
```



### 注意事项

- Scala构造器作用是完成对新对象的初始化，构造器没有返回值

- 主构造器的声明直接放置于类名之后 [可反编译查看]

- ==主构造器会执行类定义中的所有语句==，这里可以体会到Scala的函数式编程和面向对象编程融合在一起，即：构造器也是方法（函数）
  - 传递参数和使用方法和前面的函数部分内容没有区别【案例演示+反编译】

- 如果主构造器无参数，小括号可省略，构建对象时调用的构造方法的小括号也可以省略

```scala
class A{
   
}
var a = new AA
var a2 = new AA()
```

- 辅助构造器名称为this（这个和Java是不一样的）
  - 多个辅助构造器通过不同参数列表进行区分
  - 在底层是构造器重载【案例演示+反编译】

```scala
object ConDemo03 {
    def main(args: Array[String]): Unit = {
        //xxx
        val p1 = new Person2()
    }
}

//定义了一个Person类
//Person 有几个构造器 4
class Person2() {
    var name: String = _
    var age: Int = _

    def this(name : String) {
        //辅助构造器无论是直接或间接，最终都一定要调用主构造器，执行主构造器的逻辑
        //而且需要放在辅助构造器的第一行[这点和java一样，java中一个构造器要调用同类的其它构造器，也需要放在第一行]
        this()  //直接调用主构造器
        this.name = name
    }

    //辅助构造器
    def this(name : String, age : Int) {
        this() //直接调用主构造器
        this.name = name
        this.age = age
    }

    def this(age : Int) {
        this("匿名") //调用主构造器,因为 def this(name : String) 中调用了主构造器
        this.age = age
    }
    def showInfo(): Unit = {
        println("person信息如下:")
        println("name=" + this.name)
        println("age=" + this.age)
    }
}
```

- 如果想让主构造器变成私有的，可以在()之前加上private
  - 只能通过辅助构造器来构造对象了【反编译】
  - class Person2 private() {}

- 辅助构造器的声明不能和主构造器的声明一致,会发生错误
  - 即构造器名重复



### 构造器参数

- Scala类的主构造器的形参未用任何修饰符修饰，那么这个参数是局部变量

- 如果参数使用**val关键字声明**
  - Scala会将参数作为类的私有的只读属性使用 【案例+反编译】

- 如果参数使用**var关键字声明**
  - Scala会将参数作为类的成员属性使用
  - 提供属性对应的xxx()[类似getter]/xxx_$eq()[类似setter]方法
  - 这时的成员属性是私有的，但是可读写。【案例+反编译】

```scala
object ConDemo04 {
    def main(args: Array[String]): Unit = {

        val worker = new Worker("smith")
        worker.name //不能访问 inName

        val worker2 = new Worker2("smith2")
        worker2.inName  //可以访问 inName
        println("hello!")

        val worker3 = new Worker3("jack")
        worker3.inName = "mary"
        println(worker3.inName)
    }
}

//1. 如果 主构造器是Worker(inName: String) ,inName就是一个局部变量

class Worker(inName: String) {
    var name = inName
}
//. 如果 主构造器是Worker2(val inName: String) ,inName就是Worker2的一个private的只读属性
class Worker2(val inName: String) {
    var name = inName
}

// 如果 主构造器是Worker3(var inName: String) ,inName就是Worker3的一个
// 一个private 的可以读写属性
class Worker3(var inName: String) {
    var name = inName
}
```



### Bean属性

- JavaBeans规范定义了Java的属性是像getXxx（）和setXxx（）的方法
- 许多Java工具（框架）都依赖这个命名习惯
- 将Scala字段加@BeanProperty时会自动生成规范的 setXxx/getXxx 方法
- 可使用对象.setXxx() 和 对象.getXxx() 来调用属性

- 注意：给某个属性加入@BeanPropetry注解后，会生成getXXX和setXXX的方法
  - 对原来**底层自动生成类似xxx(),xxx_$eq()方法，没有冲突，二者可以共**存

```scala
import scala.beans.BeanProperty

object BeanPropertDemo {
    def main(args: Array[String]): Unit = {
        val car = new Car
        car.name = "宝马"
        println(car.name)

        //使用 @BeanProperty 自动生成 getXxx 和 setXxx
        car.setName("奔驰")
        println(car.getName())
    }
}


class Car {
    @BeanProperty var name: String = null
}
```



# 对象创建的流程分析

```scala
class Person {
    var age: Short = 90
    var name: String = _
    def this(n: String, a: Int) {
        this()
        this.name = n
        this.age = a
    }}
var p : Person = new Person("小倩",20)
```

- 加载类的信息(属性信息，方法信息)

- 在内存中(堆)开辟空间

- 使用父类的构造器(主和辅助)进行初始

- 使用主构造器对属性进行初始化 【age:90, naem nul】

- 使用辅助构造器对属性进行初始化 【 age:20, naem 小倩 】

- 将开辟的对象的地址赋给 p这个引用



# 包

- 应用场景

  - 现在有两个程序员共同开发一个项目,程序员xiaoming希望定义一个类取名 Dog ,程序员xiaoqiang也想定义一个类也叫 Dog。两个程序员为此还吵了起来,怎么办? 

    - 使用包即可以解决这个问题

      

## java中的包

- 作用
  - 区分相同名字的类
  - 当类很多时,可以很好的管理类
  - 控制访问范围
- 语法
  - package com.ttshe;

- 本质
  - 实际上就是创建不同的文件夹来保存类文件

![img](../img/scala/18.png)

- 示例
  - 使用打包技术来解决上面的问题，不同包下Dog类

```java
package com.atguigu.chapter07.javapackage;

public class TestTiger {
    public static void main(String[] args) {
        //使用xm的Tiger
        com.atguigu.chapter07.javapackage.xm.Tiger tiger01 = new com.atguigu.chapter07.javapackage.xm.Tiger();
        //使用xh的Tiger
        com.atguigu.chapter07.javapackage.xh.Tiger tiger02 = new com.atguigu.chapter07.javapackage.xh.Tiger();

        System.out.println("tiger01=" + tiger01 + "tiger02=" + tiger02);
    }
}
```



## scala中的包

- 和Java一样，Scala中管理项目可以使用包
- **Scala中的包的功能更加强大**

```scala
package com.atguigu.chapter07.scalapackage

object TestTiger {
    def main(args: Array[String]): Unit = {
        //使用xh的Tiger
        val tiger1 = new com.atguigu.chapter07.scalapackage.xh.Tiger
        //使用xm的Tiger
        val tiger2 = new com.atguigu.chapter07.scalapackage.xm.Tiger
        println(tiger1 + " " + tiger2)
    }
}
```



### 特点

- Scala包的三大作用(和Java一样)
  - 区分相同名字的类
  - 当类很多时,可以很好的管理类
  - 控制访问范围
  - 可以对类的功能进行扩展

- Scala中**包名和源码所在的系统文件目录结构要可以不一致**
- **编译后的字节码文件路径和包名会保持一致**
  - 这个工作由编译器完成

```scala
package com.atguigu.chapter07.scalapackage.hello2

object TestTiger {
    def main(args: Array[String]): Unit = {
        //使用xh的Tiger
        val tiger1 = new com.atguigu.chapter07.scalapackage.xh.Tiger
        //使用xm的Tiger
        val tiger2 = new com.atguigu.chapter07.scalapackage.xm.Tiger
        println(tiger1 + " " + tiger2)

    }
}

class Employee {

}
```



### 命名

- 规则
  - 只能包含数字、字母、下划线、小圆点.,但不能用数字开头, 也不要使用关键字
    - demo.class.exec1  //错误 , 因为class是关键字
    - demo.12a    // 错误，因为不能以数字开头
- 规范
  - 一般是小写字母+小圆点一般是 
    - com.公司名.项目名.业务模块名
      - 如com.atguigu.oa.model
      - com.atguigu.oa.controller
      - com.sina.edu.user
      - com.sohu.bank.order 

### 自动引入的包

- java.lang.*
- scala包
- Predef包



### 注意事项

- scala进行package 打包时，可如下形式

```scala
////代码说明
//1. package com.atguigu{}  表示我们创建了包 com.atguigu ,在{}中
//   我们可以继续写它的子包 scala //com.atguigu.scala, 还可以写类,特质trait,还可以写object
//2. 即sacla支持，在一个文件中，可以同时创建多个包，以及给各个包创建类,trait和object

package com.atguigu {  //包 com.atguigu
    package scala { //包 com.atguigu.scala

        class Person { // 表示在 com.atguigu.scala下创建类 Person
            val name = "Nick"

            def play(message: String): Unit = {
                println(this.name + " " + message)
            }
        }
        object Test100 { //表示在 com.atguigu.scala 创建object Test
            def main(args: Array[String]): Unit = {
                println("ok")
            }
        }
    }

}
```

- 包也可以像嵌套类那样嵌套使用（**包中有包**）
- 好处
  - **可在同一个文件中，将类(class / object)、trait 创建在不同的包中**
  - 灵活

```scala
//代码说明
//1. package com.atguigu{}  表示我们创建了包 com.atguigu ,在{}中
//   我们可以继续写它的子包 scala //com.atguigu.scala, 还可以写类,特质trait,还可以写object
//2. 即sacla支持，在一个文件中，可以同时创建多个包，以及给各个包创建类,trait和object

package com.atguigu {  //包 com.atguigu

    class User { // 在com.atguigu包下创建个 User类
    }

    package scala2 { // 创建包 com.atguigu.scala2
        class User { // 在com.atguigu.scala2 包下创建个 User类
        }
    }

    package scala { //包 com.atguigu.scala

        class Person { // 表示在 com.atguigu.scala下创建类 Person
            val name = "Nick"

            def play(message: String): Unit = {
                println(this.name + " " + message)
            }
        }
        object Test100 { //表示在 com.atguigu.scala 创建object Test
            def main(args: Array[String]): Unit = {
                println("ok")
            }
        }
    }
}
```

- 作用域原则
  - 可以直接向上访问
  - Scala中子包中直接访问父包中的内容, 大括号体现作用域
  - 提示：Java中子包使用父包的类，需要import
  - 在子包和父包 类重名时，默认采用就近原则，如果希望指定使用某个类，则带上包名即可

```scala
////代码说明
//1. package com.atguigu{}  表示我们创建了包 com.atguigu ,在{}中
//   我们可以继续写它的子包 scala //com.atguigu.scala, 还可以写类,特质trait,还可以写object
//2. 即sacla支持，在一个文件中，可同时创建多个包，以及给各个包创建类,trait和object

package com.atguigu {  //包 com.atguigu

    class User { // 在com.atguigu包下创建个 User类

    }
    package scala2 { // 创建包 com.atguigu.scala2
        class User { // 在com.atguigu.scala2 包下创建个 User类
        }
    }

    package scala { //包 com.atguigu.scala

        class Person { // 表示在 com.atguigu.scala下创建类 Person
            val name = "Nick"

            def play(message: String): Unit = {
                println(this.name + " " + message)
            }
        }

        class User {

        }

        object Test100 { //表示在 com.atguigu.scala 创建object Test
            def main(args: Array[String]): Unit = {
                println("ok")
                //可以直接使用父包的内容
                //1.如果有同名的类，则采用就近原则来使用内容(比如包)
                //2.如果是要使用父包的类，则指定路径即可
                val user = new User
                println("user=" + user) //
                val user2 = new com.atguigu.User()
                println("user2" + user2)

            }
        }
    }
}
```

- 父包要访问子包的内容时，需要import对应的类

```scala
package com.atguigu {  //包 com.atguigu

    class User { // 在com.atguigu包下创建个 User类
        def sayHello(): Unit = {
            //想使用 com.atguigu.scala2包下的 Monster
            import com.atguigu.scala2.Monster
            val monster = new Monster()
        }
    }

    package scala2 { // 创建包 com.atguigu.scala2
        class User { // 在com.atguigu.scala2 包下创建个 User类
        }
        class Monster{ //

        }
    }

    package scala { //包 com.atguigu.scala

        class Person { // 表示在 com.atguigu.scala下创建类 Person
            val name = "Nick"

            def play(message: String): Unit = {
                println(this.name + " " + message)
            }
        }

        class User {

        }

        object Test100 { //表示在 com.atguigu.scala 创建object Test
            def main(args: Array[String]): Unit = {
                println("ok")
                //我们可以直接使用父包的内容
                //1.如果有同名的类，则采用就近原则来使用内容(比如包)
                //2.如果就是要使用父包的类，则指定路径即可
                val user = new User
                println("user=" + user) //
                val user2 = new com.atguigu.User()
                println("user2" + user2)

            }
        }
    }

}
```

- 可以在同一个.scala文件中，声明多个并列的package
  - 建议嵌套的pakage不要超过3层

- 包名可以相对也可以绝对
  - 如访问BeanProperty的绝对路径是
    - `_root_. scala.beans.BeanProperty` 
    - 在一般情况下：使用相对路径来引入包，只有当包名冲突时，使用绝对路径来处理

```scala
package com.atguigu.scala2

import scala.beans.BeanProperty

class Manager(var name: String) {
    //第一种形式 [使用相对路径引入包]
    @BeanProperty var age: Int = _
    //第二种形式, 和第一种一样，都是相对路径引入
    @scala.beans.BeanProperty var age2: Int = _
    //第三种形式, 是绝对路径引入，可以解决包名冲突
    @_root_.scala.beans.BeanProperty var age3: Int = _
}

object TestBean {
    def main(args: Array[String]): Unit = {
        val m = new Manager("jack")
        println("m=" + m)
    }
}
```



### 包对象

- **包可以包含类、对象和特质trait，但不能包含函数/方法或变量的定义**
  - 这是Java虚拟机的局限
  - 为了弥补这一点不足，scala提供了**包对象的概念来解决这个问题**

```scala
package com.atguigu { //包 com.atguigu

    //说明
    //1. 在包中直接写方法，或者定义变量，就错误==>使用包对象的技术来解决
    //2. package object scala 表示创建一个包对象 scala, 他是 com.atguigu.scala这个包对应的包对象
    //3. 每一个包都可以有一个包对象
    //4. 包对象的名字需要和子包一样
    //5. 在包对象中可以定义变量，方法
    //6. 在包对象中定义的变量和方法，就可以在对应的包中使用
    //7. 在底层这个包对象会生成两个类 package.class  和 package$.class
    package object scala {
        var name = "king"

        def sayHiv(): Unit = {
            println("package object scala sayHI~")
        }
    }
    package scala { //包 com.atguigu.scala

        class Person { // 表示在 com.atguigu.scala下创建类 Person
            val name = "Nick"

            def play(message: String): Unit = {
                println(this.name + " " + message)
            }
        }

        class User {
            def testUser(): Unit = {
                println("name = " + name)
                sayHiv()
            }
        }

        object Test100 { //表示在 com.atguigu.scala 创建object Test
            def main(args: Array[String]): Unit = {
                println("name=" + name)
                name = "yy"
                sayHiv()
            }
        }
    }
}
```

![img](../img/scala/19.png)

![img](../img/scala/20.png)

- 一个包对象会生成两个类package和package$

- 注意事项
  - 每个包都可以有一个包对象。你需要在父包中定义它
  - 包对象名称需要和包名一致，一般用来对包的功能补充



# 包的可见性



## java中

- java提供四种访问控制修饰符号控制方法和变量的访问权限
  - 公开级别
    - 用public 修饰,对外公开
  - 受保护级别
    - 用protected修饰,对子类和同一个包中的类公开
  - 默认级别
    - 没有修饰符号,向同一个包的类公开
  - 私有级别
    - 用private修饰,只有类本身可以访问,不对外公开

<img src="../img/scala/21.png" alt="1571372189170" style="zoom:80%;" />

- 修饰符可以用来修饰类中的属性，成员方法以及类

- 只有默认的和public才能修饰类



## scala中

- 在Java中，访问权限分为
  - public，private，protected和默认
- 在Scala中，可通过类似的修饰符达到同样的效果，但使用上有区别

```scala
object Testvisit {
    def main(args: Array[String]): Unit = {
        val  c = new Clerk()
        c.showInfo()
        Clerk.test(c)
    }
}
class Clerk {
    var name : String = "jack"
    private var sal : Double = 9999.9
    def showInfo(): Unit = {
        println(" name " + name + " sal= " + sal)
    }
}
object Clerk{
    def test(c : Clerk): Unit = {
        //这里体现出在伴生对象中，可以访问c.sal
        println("test() name=" + c.name + " sal= " + c.sal)
    }
}
```

- 当==属性访问权限==为默认时，从底层看属性是==private==的，但是因为提供了xxx_$eq()[类似setter]/xxx()[类似getter] 方法，因此从使用效果看是任何地方都可以访问)

- 当==方法访问权限==为默认时，默认为==public==访问权限

- private为私有权限，只在类的内部和伴生对象中可用 【案例演示】

- protected为受保护权限，==scala中受保护权限比Java中更严格==，只能子类访问，同包无法访问 

- 在scala中没有public关键字,即不能用public显式的修饰属性和方法。【案演】

- 包访问权限（表示属性有了限制。同时包也有了限制），这点和Java不一样，体现出Scala包使用的灵活性

```scala
package com.atguigu.chapter07.visit

object Testvisit {
    def main(args: Array[String]): Unit = {
        val c = new Clerk()

        c.showInfo()
        Clerk.test(c)

        //创建一个Person对象
        val p1 = new Person
        println(p1.name)
    }
}

//类
class Clerk {
    var name: String = "jack" //
    private var sal: Double = 9999.9
    protected var age = 10
    var job : String = "大数据工程师"

    def showInfo(): Unit = {
        //在本类可以使用私有的
        println(" name " + name + " sal= " + sal)
    }
}

//当一个文件中出现了 class Clerk 和 object Clerk
//1. class Clerk 称为伴生类
//2. object Clerk 的伴生对象
//3. 因为scala设计者将static拿掉, 就是设计了 伴生类和伴生对象的概念
//4. 伴生类 写非静态的内容 伴生对象 就是静态内容
//5.
object Clerk {
    def test(c: Clerk): Unit = {
        //这里体现出在伴生对象中，可以访问c.sal
        println("test() name=" + c.name + " sal= " + c.sal)
    }
}

class Person {
    //这里我们增加一个包访问权限
    //下面private[visit] ： 1，仍然是private 2. 在visit包(包括子包)下也可以使用name ,相当于扩大访问范围

    protected[visit] val name = "jack"
}
```



# 包的引入

- Scala引入包也是使用import, **基本的原理和机制和Java一样**
- Scala中的import功能更加强大，也更灵活
- 因为Scala语言源自于Java，所以**java.lang**包中的类会自动引入到当前环境中，而Scala中的**scala包和Predef包的类也会自动**引入到当前环境中，即起其下面的类可以直接使用
- 如果想要把其他包中的类引入到当前环境中，需要使用import语言

- 在Scala中，**import语句可以出现在任何地方，并不仅限于文件顶部**
- import语句的作用一直延伸到包含该语句的块末尾
  - 好处：在需要时在引入包，**缩小import 包的作用范围**，提高效率

```scala
class User {
    import scala.beans.BeanProperty
    @BeanProperty var  name : String = ""
}
class Dog {
    @BeanProperty var  name : String = "" //可以吗?
}
```

- Java中如果想要导入包中所有的类，可以通过通配符*，Scala中采用下 _  [案例演示]

- 如果不想要某个包中全部的类，而是其中的几个类，可以采用选取器(大括号)

```scala
def test(): Unit = {
    //可以使用选择器，选择引入包的内容，这里，我们只引入 HashMap, HashSet
    import scala.collection.mutable.{HashMap, HashSet}
    var map = new HashMap()
    var set = new HashSet()
}
```

- 如果引入的多个包中含有相同的类，那么可将不需要的类进行重命名进行区分，这个就是重命名

```scala
def test2(): Unit = {
    //下面的含义是 将 java.util.HashMap 重命名为 JavaHashMap
    import java.util.{ HashMap=>JavaHashMap, List}
    import scala.collection.mutable._
    var map = new HashMap() // 此时的HashMap指向的是scala中的HashMap
    var map1 = new JavaHashMap(); // 此时使用的java中hashMap的别名
}
```

-  如果某个冲突的类根本就不会用到，那么这个类可以直接隐藏掉

```scala
import java.util.{ HashMap=>_, _} // 含义为 引入java.util包的所有类，但是忽略 HahsMap类.
var map = new HashMap() // 此时的HashMap指向的是scala中的HashMap, 而且idea工具，的提示也不会显示java.util的HashMaple 
```



# 面向对象编程



## 抽象

![img](../img/scala/22.png)

```scala

object BankDemo {
    def main(args: Array[String]): Unit = {
        //开卡
        val account = new Account("gh00001",890.4,"111111")
        account.query("111111")
        account.withDraw("111111", 100.0)
        account.query("111111")

    }
}

//编写一个Account类
class Account(inAccount: String, inBalance: Double, inPwd: String) {
    /*
  属性：
账号，余额，密码
  方法:
查询
取款
存款

   */
    val accountNo = inAccount
    var balance = inBalance
    var pwd = inPwd

    //查询
    def query(pwd: String): Unit = {
        if (!this.pwd.equals(pwd)) {
            println("密码错误")
            return
        }

        printf("账号为%s 当前余额是%.2f\n", this.accountNo, this.balance)
    }

    //取款
    def withDraw(pwd:String,money:Double): Any = {
        if (!this.pwd.equals(pwd)) {
            println("密码错误")
            return
        }
        //判断money是否合理
        if (this.balance < money) {
            println("余额不足")
            return
        }
        this.balance -= money
        money
    }
}
```



## 三大特征

- 面向对象编程有三大特征：封装、继承和多态



### 封装

- 封装(encapsulation)就是把抽象出的数据和对数据的操作封装在一起,数据被保护在内部
- 程序的其它部分只有通过被授权的操作(成员方法),才能对数据进行操作。



- 好处
  - 隐藏实现细节
  - 提可以对数据进行验证，保证安全合理
  - 同时可以加入业务逻辑

- 如何体现封装
  - 对类中的属性进行封装
  - 通过成员方法，包实现封装

- 具体实现
  - 将属性进行私有化
  - 提供一个公共的**set**方法，用于对**属性判断并赋**值
  - 提供一个公共的get方法，用于获取属性的值

```scala
def  setXxx(参数名 : 类型) : Unit = {
    //加入数据验证的业务逻辑
    属性 = 参数名   
}
```

```scala
def getXxx() [: 返回类型] = {
    return 属性
}
```

- 示例
- 不能随便查看人的年龄,工资等隐私，并对输入的年龄进行合理的验证[要求1-120之间]

```scala
class Person {
    var name: String = _
    //var age ; //当是public时，可以随意的进行修改，不安全
    private var age: Int = _
    private var salary: Float = _
    private var job: String = _
    
    def setAge(age: Int): Unit = {
        if (age >= 0 && age <= 120) {
            this.age = age
        } else {
            println("输入的数据不合理");
            //可考虑给一个默认值
            this.age = 20
        }}
}
```

- 前面讲的Scala的封装特性，大家发现和Java是一样的，下面我们看看Scala封装还有哪些特点
- Scala中为了简化代码的开发，当声明属性时，本身就自动提供了对应setter/getter方法
  - 如果属性声明为private的，那么自动生成的setter/getter方法也是private的
  - 如果属性省略访问权限修饰符，那么自动生成的setter/getter方法是public的[案例+反编译+说明]

-  因此我们如果只是对一个属性进行简单的set和get ，只要声明一下该属性(属性使用默认访问修饰符) 不用写专门的getset，默认会创建，访问时，直接对象.变量。这样也是为了保持访问一致性 [案例]

- 从形式上看 dog.food 直接访问属性，其实底层仍然是访问的方法,  看一下反编译的代码就明白

- 有了上面的特性，目前很多新的框架，在进行反射时，也支持对属性的直接反射



### 继承

- 基本语法
  - class 子类名 extends 父类名  { 类体 }
- 继承可以解决代码复用,让我们的编程更加靠近人类思维
  - 当多个类存在相同的属性(变量)和方法时,可以从这些类中抽象出父类(比如Student),在父类中定义这些相同的属性和方法
  - 所有的子类不需要重新定义这些属性和方法，只需要通过extends语句来声明继承父类即可
- 和Java一样，Scala也支持类的单继承

![img](../img/scala/23.png)

- 示例

```scala
object Extends01 {
    def main(args: Array[String]): Unit = {
        //使用
        val student = new Student
        student.name = "jack" //调用了student.name() //调用到从Person继承的name()
        student.studying()
        student.showInfo()
    }
}

class Person { //Person类
    var name : String = _
    var age : Int = _
    def showInfo(): Unit = {
        println("学生信息如下：")
        println("名字：" + this.name)
    }
}

//Student类继承Person
class Student extends Person {
    def studying(): Unit = {
        //这里可以使用父类的属性
        println(this.name + "学习 scala中....")
    }
}
```

- 好处
  - 代码的复用性提高了
  - 代码的扩展性和维护性提高了
  - 面试官问:当我们修改父类时，对应的子类就会继承相应的方法和属性】

