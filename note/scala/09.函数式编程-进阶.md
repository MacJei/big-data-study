# partial function 偏函数



## 使用

- 思考
  - 给你一个集合val list = List(1, 2, 3, 4, "abc") ，请完成如下要求
    - 将集合list中的所有数字+1，并返回一个新的集合
    - 要求忽略掉非数字 的元素，即返回的 新的集合 形式为 (2, 3, 4, 5)
  - 思路：filter + map返回新的集合

```scala
def main(args: Array[String]): Unit = {

    val list = List(1, 2, 3, 4, "hello")

    // 判断是否是Int类型
    def f1(n: Any): Boolean ={
        n.isInstanceOf[Int]
    }
    // 转换过滤下来的Any类型转换为Int类型
    def f2(n: Any):Int ={
        n.asInstanceOf[Int]
    }

    def f3(n: Int): Int = {
        n + 1
    }
    // 方式1：由于list是Any类型，需要进行类型转换为Int
    val re1 = list.filter(f1).map(f2).map(f3)
    println(re1)

    // 方式2：使用模式识别判断类型
    def addOne(n:Any): Any ={
        n match {
            case i:Int => i + 1
            case _=>
        }
    }
    var re2 = list.map(addOne)
    println(re2)

}
//result:
//List(2, 3, 4, 5)
//List(2, 3, 4, 5, ())
```

- 虽然解决了问题，但是处理比较复杂，方式2也没有很好的解决
- 使用偏函数解决
  - 定义一个PartialFunction[Any,Int] 
    - 表示偏函数接收的参数类型是Any
    - 返回类型是Int
  - isDefinedAt(x: Any)
    - 返回true 则调用 apply 构建对象实例
    - 返回false 则过滤
  - apply 构造器 ,对传入的值 + 1,并返回（新的集合）
  - 注意：如果是使用偏函数，则不能使用map，==应该使用collect==

```scala
def main(args: Array[String]): Unit = {
    val list = List(1, 2, 3, 4, "hello")
    val partialFun = new PartialFunction[Any,Int] {
        override def isDefinedAt(x: Any) = {
            x.isInstanceOf[Int]
        }
        override def apply(v1: Any) = {
            v1.asInstanceOf[Int]+1
        }
    }
    val re = list.collect(partialFun)
    println(re)
}
```



## 小结

1) 使用构建特质的实现类(使用的方式是PartialFunction的匿名子类)

2) PartialFunction 是个特质(看源码)

3) 构建偏函数时，参数形式  [Any, Int]是泛型，第一个表示参数类型，第二个表示返回参数

4) 当使用偏函数时，会遍历集合的所有元素，编译器执行流程时先执行isDefinedAt()如果为true ,就会执行 apply, 构建一个新的Int 对象返回

5) 执行isDefinedAt() 为false 就过滤掉这个元素，即不构建新的Int对象.

6) map函数不支持偏函数，因为map底层的机制就是所有循环遍历，无法过滤处理原来集合的元素

7) collect函数支持偏函数



## 简写

```scala
def main(args: Array[String]): Unit = {
    val list = List(1, 2, 3, 4, "hello")
    // 简写1
    def partialFun : PartialFunction[Any,Int] = {
        case i:Int => i+1 // case自动转换为偏函数
    }
    val re = list.collect(partialFun)
    println(re)

    // 简写2
    val re2 = list.collect {
        case i: Int => i + 1
    }
    println(re2)
}
```



# 作为参数的函数

- 函数作为一个变量传入到了另一个函数中，那么该作为参数的函数的类型是
  - function1
  - 即：(参数类型) => 返回类型

```scala
def main(args: Array[String]): Unit = {
    def plus(x: Int) = 3+x
    val re = Array(1,2,3).map(plus(_))
    println(re.mkString(" "))
    println("参数类型="+(plus _))
}
// result
//4 5 6
//参数类型=<function1>
```

- `map(plus(_))` 中的`plus(_) `就是将plus这个函数当做一个参数传给了map
- `_`这里代表从集合中遍历出来的一个元素
- `plus(_) `这里也可以写成 `plus`
  - 表示对 Array(1,2,3,4) 遍历，将每次遍历的元素传给plus的 x
- `def map[B, That](f: A => B)` 的声明中的 f: A => B 一个函数



# 匿名函数

- 没有名字的函数
- 通过函数表达式来设置匿名函数

```scala
def main(args: Array[String]): Unit = {
    val plus3 = (x: Int) => {
        println("plus3")
        x+3
    }
    println(plus3(1))

    val f1 = (n1:Int,n2:Int) => n1+n2
    println("f1的类型="+f1)
    println(f1(1,2))
}
// result:
//plus3
//4
//f1的类型=<function2>
//3
```

- 说明

  - 不需要写 def 函数名

  - 不需要写返回类型，使用类型推导

  - =  变成  =>

  - 如果有多行，则使用{} 包括

    

# 高阶函数

- 能够接受函数作为参数的函数，叫做高阶函数 (higher-order function)
- 使应用程序更加健壮

